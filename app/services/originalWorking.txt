import React, { useState, useEffect, useRef } from 'react';
import ChatWindow from './components/ChatWindow';
import ChatInput from './components/ChatInput';
import DynamicBackground from './components/DynamicBackground';
import ScrollFooterArrow from './components/ScrollFooterArrow';
import FAQSelection from './components/FAQSelection';
import QuizComponent from './components/QuizComponent';
import MultimediaDisplay from './components/MultimediaDisplay';
import LiveStatsChart from './components/LiveStatsChart';
import './styles/App.css';

function App() {
  const [messages, setMessages] = useState([]);
  const moreContentRef = useRef(null);
  const [showArrow, setShowArrow] = useState(true);

  const handleSendMessage = async (text) => {
    const now = Date.now();
    // Create user message with a fixed timestamp.
    const userMessage = { id: now, text, sender: 'user', timestamp: now };
    setMessages((prev) => [...prev, userMessage]);

    // Insert a placeholder bot message with loading: true.
    const botPlaceholder = { 
      id: now + 1, 
      text: "", 
      sender: 'bot', 
      prompt: text,
      loading: true, 
      timestamp: null,
    };
    setMessages((prev) => [...prev, botPlaceholder]);

    try {
      const response = await fetch("/hackaton/chat", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ prompt: text })
      });
      
      if (!response.ok) {
        throw new Error(`HTTP-Error: ${response.status}`);
      }
      
      const data = await response.json();
      const botText = data.output?.message?.content?.[0]?.text || "No answer received.";
      
      // Update the placeholder message with the new text and timestamp.
      setMessages((prevMessages) =>
        prevMessages.map((msg) =>
          msg.id === botPlaceholder.id 
            ? { ...msg, text: botText, loading: false, timestamp: Date.now() }
            : msg
        )
      );
    } catch (error) {
      console.error("Error fetching chatbot answer:", error);
      setMessages((prevMessages) =>
        prevMessages.map((msg) =>
          msg.id === botPlaceholder.id 
            ? { ...msg, text: "Error fetching answer.", loading: false, timestamp: Date.now() }
            : msg
        )
      );
    }
  };

  const handleFeedback = (messageId, type) => {
    console.log(`Feedback for message ${messageId}: ${type}`);
  };

  const handleRegenerate = async (messageId) => {
    console.log(`Regenerating message ${messageId}`);
    const targetMessage = messages.find(m => m.id === messageId && m.sender === 'bot');
    if (targetMessage && targetMessage.prompt) {
      // Set the target message to loading.
      setMessages(prev =>
        prev.map(msg =>
          msg.id === messageId ? { ...msg, text: "", loading: true } : msg
        )
      );
      
      try {
        const response = await fetch("/hackaton/chat", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ prompt: targetMessage.prompt })
        });
        
        if (!response.ok) {
          throw new Error(`HTTP-Error: ${response.status}`);
        }
        
        const data = await response.json();
        const newBotText = data.output?.message?.content?.[0]?.text || "No answer received.";
        setMessages(prev =>
          prev.map(msg =>
            msg.id === messageId
              ? { ...msg, text: newBotText, loading: false, timestamp: Date.now() }
              : msg
          )
        );
      } catch (error) {
        console.error("Error regenerating answer:", error);
        setMessages(prev =>
          prev.map(msg =>
            msg.id === messageId
              ? { ...msg, text: "Error regenerating answer.", loading: false, timestamp: Date.now() }
              : msg
          )
        );
      }
    }
  };

  const handleFAQSelect = (question) => {
    handleSendMessage(question);
  };

  // Always show the scroll-down arrow initially.
  useEffect(() => {
    setShowArrow(true);
  }, [messages]);

  const scrollToMoreContent = () => {
    if (moreContentRef.current) {
      moreContentRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  };

  return (
    <Box sx={{ minHeight: '100vh', backgroundColor: '#121212' }}>
      <DynamicBackground />
      {/* Chat Area */}
      <Box sx={{ p: 1 }}>
        <ChatWindow messages={messages} onFeedback={handleFeedback} onRegenerate={handleRegenerate} />
        <ChatInput onSend={handleSendMessage} />
      </Box>
      {/* Additional Content (FAQs, etc.) */}
      <Box id="more-content" ref={moreContentRef} sx={{ p: 2 }}>
        <FAQSelection onSelect={handleFAQSelect} />
        <QuizComponent />
        <MultimediaDisplay type="video" src="/video.mp4" caption="Match Highlights" />
        <LiveStatsChart />
      </Box>
      {/* Floating Scroll-Down Arrow */}
      <ScrollFooterArrow show={showArrow} onClick={scrollToMoreContent} />
    </Box>
  );
}

export default App;
